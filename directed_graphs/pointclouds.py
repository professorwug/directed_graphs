# AUTOGENERATED! DO NOT EDIT! File to edit: 52_Directed_SBM_On_Manifold.ipynb (unless otherwise specified).

__all__ = ['sbm', 'outward_flow', 'inward_flow', 'visualize_points_on_flow_field']

# Cell
import numpy as np
def sbm(N, k):
    """sbm: Construct a stochastic block model

    Args:
        N (integer): Graph size
        k (integer): Number of clusters
        pij (float): Probability of intercluster edges
        pii (float): probability of intracluster edges

    Returns:
        A (numpy.array): Adjacency matrix
        gt (numpy.array): Ground truth cluster labels
        coords(numpy.array): plotting coordinates for the sbm
    """
    clust_size = np.floor(N / k).astype(int)
    # make labels
    gt = np.arange(k)
    gt = np.tile(gt, (1, clust_size)).squeeze()
    leftover = N - np.size(gt)
    leftover = np.random.randint(k, size=leftover).squeeze()
    gt = np.hstack((gt, leftover))
    gti = np.argsort(gt)
    gt = gt[gti]
    # generate coordinates
    centroids = np.linspace(0, 2 * np.pi, endpoint=False, num=k-1)
    coords = np.empty(shape=(0, 2))
    for i in range(k-1):
        clustersize = np.sum(np.isin(gt, i))
        print(clustersize)
        pts = np.random.multivariate_normal(
            [10 * np.cos(centroids[i]), 10 * np.sin(centroids[i])], np.eye(2),
            int(clustersize))
        coords = np.vstack((coords, pts))
    clustersize = np.sum(np.isin(gt, k-1))
    print(clustersize)
    pts = np.random.multivariate_normal(
            [0, 0], np.eye(2),
            int(clustersize))
    coords = np.vstack((coords, pts))
    return gt, coords


# Cell
def outward_flow(x):
  if np.allclose(x,[0,0]):
    return np.array([0,0])
  else:
    if len(x.shape) == 3:
      r = x / np.linalg.norm(x,axis=2)[:,:,None]
    elif len(x.shape) == 2:
      r = x / np.linalg.norm(x,axis=1)[:,None]
    return r

# Cell
def inward_flow(x):
  if np.allclose(x,[0,0]):
    return np.array([0,0])
  else:
    if len(x.shape) == 3:
      r = - x / np.linalg.norm(x,axis=2)[:,:,None]
    elif len(x.shape) == 2:
      r = - x / np.linalg.norm(x,axis=1)[:,None]
    return r

# Cell
import matplotlib.pyplot as plt
def visualize_points_on_flow_field(X,flow_artist,colors):
    # controls the x and y axes of the plot
    # linspace(min on axis, max on axis, spacing on plot -- large number = more field arrows)
    minx = min(X[:,0])-1
    maxx = max(X[:,0])+1
    miny = min(X[:,1])-1
    maxy = max(X[:,1])+1
    x, y = np.meshgrid(np.linspace(minx,maxx,20),np.linspace(miny,maxy,20))
    xy_t = np.concatenate([x[:,:,None],y[:,:,None]],axis=2)
    uv = flow_artist(xy_t)
    u = uv[:,:,0]
    v = uv[:,:,1]
    fig, ax = plt.subplots()
    ax.quiver(x,y,u,v)
    sc = ax.scatter(X[:,0],X[:,1], c=colors)
    ax.legend()
    # plt.legend(handles = sc.legend_elements()[0], title="Blobs", labels=list(range(self.nnodes)))
    """Display all open figures."""
    plt.show()