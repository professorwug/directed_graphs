# AUTOGENERATED! DO NOT EDIT! File to edit: 05c05b Learning flow around a fixed diffusion map.ipynb (unless otherwise specified).

__all__ = ['DiffusionDistanceFlowEmbedder', 'DiffusionDistanceFlowEmbedder', 'FixedDiffusionMapEmbedding',
           'FlowEmbedderAroundDiffusionMap']

# Cell
from .multiscale_flow_embedder import MultiscaleDiffusionFlowEmbedder
from .flow_embedding_training_utils import FETrainer, visualize_points, save_embedding_visualization
class DiffusionDistanceFlowEmbedder(FETrainer):
    def __init__(self, X, flows, labels, device = device):
        super().__init__(X, flows, labels, device = device)
        self.vizfiz = [
            save_embedding_visualization,
            visualize_points,
        ]
        loss_weights = {
            "diffusion":0,
            "smoothness":0,
            "reconstruction":0,
            "diffusion map regularization":1,
            "flow cosine loss": 0,
        }
        self.FE = MultiscaleDiffusionFlowEmbedder(
            X = X,
            flows = flows,
            sigma_graph = 1,
            flow_strength_graph = 1,
            device = device,
            use_embedding_grid = False,
        ).to(device)
        self.title = "Diffusion Distance FE"


# Cell
from .multiscale_flow_embedder import MultiscaleDiffusionFlowEmbedder
from .flow_embedding_training_utils import FETrainer, visualize_points, save_embedding_visualization
class DiffusionDistanceFlowEmbedder(FETrainer):
    def __init__(self, X, flows, labels, device = device):
        super().__init__(X, flows, labels, device = device)
        self.vizfiz = [
            save_embedding_visualization,
            visualize_points,
        ]
        loss_weights = {
            "diffusion":0,
            "smoothness":0,
            "reconstruction":0,
            "diffusion map regularization":1,
            "flow cosine loss": 1,
        }
        self.FE = MultiscaleDiffusionFlowEmbedder(
            X = X,
            flows = flows,
            sigma_graph = 1,
            flow_strength_graph = 1,
            device = device,
            use_embedding_grid = False,
        ).to(device)
        self.title = "Diffusion Distance FE"


# Cell
import torch.nn as nn
from scipy.sparse import diags
from .utils import make_sparse_safe, diffusion_coordinates
class FixedDiffusionMapEmbedding(nn.Module):
    """
    Computes the diffusion map of the provided data.
    If `precompute = True`, computes diffusion map of input graph when initialized
    and returns this map whenever called (assuming that all subsequent input points
    are the same as initially)
    When false, dynamically computes diffusion map on passed points.
    (False is not yet implemented.)
    """
    def __init__(self, P_graph_torch, t, precompute = True, embedding_dimension=2, device=torch.device('cpu'), **kwargs):
        super().__init__()
        self.t = t
        self.device = device
        # convert P_graph to numpy (nothing we do past here needs to be differentiable)
        P_graph = copy.copy(P_graph_torch).detach().cpu().numpy()
        # make sparse array
        P_graph = make_sparse_safe(P_graph)
        # turn into P_symmetric, by multiplying
        # D^{1/2} D^{-1} P D^{-1/2}
        D = P_graph.sum(axis = 0)
        D_negative_one_half = diags(D ** (-0.5))
        D_positive_one_half = diags(D ** (0.5))
        P_symmetric = D_positive_one_half @ P_graph @ D_negative_one_half
        # pass to diffusion map function
        diff_map = diffusion_coordinates(P_symmetric, D, t=t)
        print("diff map is", diff_map)
        self.diff_coords = diff_map[:embedding_dimension]
        self.diff_coords = self.diff_coords.T
        self.diff_coords = self.diff_coords.real
        self.diff_coords = torch.tensor(self.diff_coords.copy())
        self.diff_coords = self.diff_coords.to(device)
        print(self.diff_coords.shape)
    def forward(self, X, **kwargs):
        return self.diff_coords


# Cell
import copy
from .multiscale_flow_embedder import MultiscaleDiffusionFlowEmbedder
from .flow_embedding_training_utils import FETrainer, visualize_points, save_embedding_visualization
from .diffusion_flow_embedding import affinity_matrix_from_pointset_to_pointset
import torch.nn.functional as F
class FlowEmbedderAroundDiffusionMap(FETrainer):
    def __init__(self, X, flows, labels, device = device, sigma_graph = 1, flow_strength_graph = 1):
        super().__init__(X, flows, labels, device = device)
        self.vizfiz = [
            save_embedding_visualization,
            visualize_points,
        ]
        loss_weights = {
            "diffusion":1,
            "smoothness":0,
            "reconstruction":0,
            "diffusion map regularization":0,
            "flow cosine loss": 0,
        }
        P_graph = affinity_matrix_from_pointset_to_pointset(X,X,flows,sigma=sigma_graph,flow_strength=0)
        P_graph = F.normalize(P_graph, p=1, dim=1)
        self.FE = MultiscaleDiffusionFlowEmbedder(
            X = X,
            flows = flows,
            sigma_graph = sigma_graph,
            flow_strength_graph = flow_strength_graph,
            device = device,
            use_embedding_grid = False,
            embedder = FixedDiffusionMapEmbedding(P_graph, t=1, device=device)
        ).to(device)
        self.title = "Diffusion Distance FE"
