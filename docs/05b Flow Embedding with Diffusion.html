---

title: Flow Embedding with Diffusion


keywords: fastai
sidebar: home_sidebar



nb_path: "05b Flow Embedding with Diffusion.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 05b Flow Embedding with Diffusion.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The first generation of the flow embedding network was based around the preservation of distances in the embedding space. It's now obvious that this was the wrong tact. Caring about distance preservation puts most emphasis on far away points (including pathological cases, when there's no connectivity and the distance is "infinite").</p>
<p>Affinities do the trick here much better. They naturally emphasize only local distances, and allow the network to heavily discount (if not outright ignore) long-range connectivity.</p>
<p>This locality creates a new model of flow. Previously, our network used euclidean lines between points, and used the flow only to determine the length of each line. Going against (and especially, going perpendicular) to the flow was <em>possible</em>, just not easy.</p>
<p>With the diffusion-based model, we think in terms of probabilities, rather than distances. 
This has a couple of downstream effects:</p>
<ul>
<li>Going with the flow is <em>highly</em> encouraged. Going against or even perpendicular is given (depending on the kernel function used) a probability close to zero.</li>
<li>Points travel on <em>paths</em> dictated by the flow. The likelihood of reaching point $i$ from $j$ is governed not by the <em>shortest</em> path, but the aggregate of all paths, weighted by probability. This has the dual effects of diminishing the effect of outliers, and providing an intuitive model of motion. You don't have to reason about which path is "lowest energy", just which path is most likely based on the directions of flow.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="The-Pieces-of-the-Algorithm">The Pieces of the Algorithm<a class="anchor-link" href="#The-Pieces-of-the-Algorithm"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We compute the probabilities of transition between the points with three steps:</p>
<ol>
<li>Learn a "Flow Artist": a neural network to learn flow over the euclidean field.<ul>
<li>This is currently a function of two variables $F(x,y): \mathbb{R}^2 \to \mathbb{R}$. The direction of flow is the negative gradient $-\Delta F$.</li>
</ul>
</li>
<li>Compute the probabilities of transition between the grid points and the embeddings of points.</li>
<li>Compute the probabilities of transition from grid points to grid points.</li>
</ol>
<p>The probability of transitioning from one point to another is then the amalgam of these steps: we transition to the grid, transition within the grid for $t$ steps, and then transition back to a point. Each probability gives a matrix.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Probability-Kernel-from-Flow">Probability Kernel from Flow<a class="anchor-link" href="#Probability-Kernel-from-Flow"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The foundation of these is the conversion from <em>flow</em> (the vector field) to probabilities of transition. This is done using a kernel based on the degree of divergence between the direction specified and the flow, as below, where $r$ is the flow direction (a vector) and $v$ is the direction of the edge.
{% raw %}
$$ e^{-(\|r\|^2 - r \cdot v)/\sigma} $$
{% endraw %}
When the flow is aligned with the direction, this returns 1. When it is perpendicular, $e^{-\|r\|^2/\sigma}$, and when against the flow, $e^{-2\|r\|^2/\sigma}$.</p>
<p>We should tune $\sigma$ to ensure that a 45 degree angle returns a quantity significantly above zero.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We'll create a function that performs this operation on batches of flows and directions. The input will be an array of flows (e.g. the flow per point), and a batch of directions (e.g. NESW for each point). It will, of course, use PyTorch for backpropogation capable operations</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="affinity_from_flow" class="doc_header"><code>affinity_from_flow</code><a href="https://github.com/professorwug/directed_graphs/tree/master/directed_graphs/diffusion_flow_embedding.py#L11" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>affinity_from_flow</code>(<strong><code>flows</code></strong>, <strong><code>directions_array</code></strong>, <strong><code>sigma</code></strong>=<em><code>1</code></em>)</p>
</blockquote>
<p>Compute probabilities of transition in the given directions based on the flow.</p>
<h2 id="Parameters">Parameters<a class="anchor-link" href="#Parameters"> </a></h2><p>flows : torch tensor of shape n_points x n_dims
    <em>description</em>
directions_array : torch tensor of shape n_directions x n_points x n_dims. Assumed to be normalized.
    <em>description</em>
sigma : int, optional
    kernel bandwidth, by default 1
returns (n_points)</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="A-Sample-Computation">A Sample Computation<a class="anchor-link" href="#A-Sample-Computation"> </a></h3>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">flows</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Flows for each of 4 points</span>
<span class="n">directions_array</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># 7 directions, for each of the four points</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Next, take a dot product between the directions and the flow, to get a strength of flow at each point in each direction</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">dot_products</span> <span class="o">=</span> <span class="p">(</span><span class="n">directions_array</span> <span class="o">*</span> <span class="n">flows</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dot_products</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>torch.Size([7, 4])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Convert these dot products into distances by subtracting the norm squared of the flows from the dot product with the flow. If exactly with the flow, we get zero.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">distance_from_flow</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">flows</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">dot_products</span>
<span class="n">distance_from_flow</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([[ 0.0711, -0.2562,  0.3984,  0.5661],
        [ 0.2636,  0.6121,  0.2271,  0.7877],
        [-0.1338,  0.3220,  0.4197,  0.9992],
        [ 0.2993,  0.3073,  0.3595,  0.5788],
        [-0.2854,  0.2610,  0.3268,  0.7972],
        [ 0.0082,  0.5222,  0.1488,  0.8046],
        [ 0.3287,  0.9110,  0.7553,  0.8306]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Testing">Testing<a class="anchor-link" href="#Testing"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>To ensure this is working as expected, we'll try computations on a single sample point, with flow going in direction (1,1). We'll compare this with six directions: one with, one against, and the rest in the shape of a grid.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">flow</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
<span class="n">directions</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span>
  <span class="p">[[</span><span class="mf">0.7</span><span class="p">,</span><span class="mf">0.7</span><span class="p">]],</span>
  <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span>
  <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span>
  <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
  <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span>
  <span class="p">[[</span><span class="o">-</span><span class="mf">0.7</span><span class="p">,</span><span class="o">-</span><span class="mf">0.7</span><span class="p">]]</span>
<span class="p">])</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
<span class="n">probs</span> <span class="o">=</span> <span class="n">affinity_from_flow</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span><span class="n">directions</span><span class="p">,</span><span class="n">sigma</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">probs</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([[0.3012, 0.1353, 0.1353, 0.0025, 0.0025, 0.0011]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>If this went according to plan, the direction with the flow should have probability 1, and the one against should have probability near zero.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">probs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[&lt;matplotlib.lines.Line2D at 0x126f160d0&gt;]</pre>
</div>

</div>

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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"
>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>$\sigma=0.5$ works well here. In particular, the 45 degree angles have fairly high probability, while still being less than the probability of going straight.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Computing-Transition-Probabilities-Between-a-Grid-and-Points,-and-Vice-Versa">Computing Transition Probabilities Between a Grid and Points, and Vice Versa<a class="anchor-link" href="#Computing-Transition-Probabilities-Between-a-Grid-and-Points,-and-Vice-Versa"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The next functions will take three inputs: a set of points, a grid, and flows at each point and each point on the grid. It is tasked with returning three matrices: a transition matrix between the points and the grid, a transition matrix between the grid and the points, and the transition matrix from the grid to the grid.</p>
<p>These tasks should be separated, as each is called in different circumstances.</p>
<ul>
<li>The grid-to-point (and vv) function will be called each time the points are moved, or the grid is updated, or the flow is updated.</li>
<li>The grid-to-grid function will be called whenever the grid is updated, or the flow is updated.</li>
</ul>
<p>Both can be encapsulated in the same function, which computes an affinity matrix from pointset 1 to pointset 2.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The logic of the functions:</p>
<ol>
<li>For each point in set 1, sort the points in set 2 by distance.</li>
<li>Choose the $n$ nearest neighbors (optional computational boost), and compute the transition probabilities to them, storing the results in the affinity matrix.</li>
</ol>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="affinity_matrix_from_pointset_to_pointset" class="doc_header"><code>affinity_matrix_from_pointset_to_pointset</code><a href="https://github.com/professorwug/directed_graphs/tree/master/directed_graphs/diffusion_flow_embedding.py#L46" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>affinity_matrix_from_pointset_to_pointset</code>(<strong><code>pointset1</code></strong>, <strong><code>pointset2</code></strong>, <strong><code>flows</code></strong>, <strong><code>n_neighbors</code></strong>=<em><code>None</code></em>, <strong><code>sigma</code></strong>=<em><code>0.5</code></em>)</p>
</blockquote>
<p>Compute affinity matrix between the points of pointset1 and pointset2, using the provided flow.</p>
<h2 id="Parameters">Parameters<a class="anchor-link" href="#Parameters"> </a></h2><p>pointset1 : torch tensor, n1 x d
    The first pointset, to calculate affinities <em>from</em>
pointset2 : torch tensor, n2 x d
    The second pointset, to calculate affinities <em>to</em> (from pointset1)
flow : a function that, when called at a point, gives the flow at that point
n_neighbors : number of neighbors to include in affinity computations. All neighbors beyond it are given affinity zero
(currently not implemented)</p>
<p>Returns:
Affinity matrix: torch tensor of shape n1 x n2</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Building-the-function">Building the function<a class="anchor-link" href="#Building-the-function"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This is an illustration of how the function should work.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">pointset1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">pointset2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">flow</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">pointset1</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([[0.4085, 0.5223],
        [0.4046, 0.2863],
        [0.5993, 0.2879],
        [0.4726, 0.7379]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">pointset2</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([[0.2435, 0.1213],
        [0.7581, 0.8408],
        [0.6380, 0.9607],
        [0.4217, 0.5043],
        [0.4438, 0.2772],
        [0.1088, 0.3275],
        [0.3015, 0.4619]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">pointset2</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([[[0.2435],
         [0.1213]],

        [[0.7581],
         [0.8408]],

        [[0.6380],
         [0.9607]],

        [[0.4217],
         [0.5043]],

        [[0.4438],
         [0.2772]],

        [[0.1088],
         [0.3275]],

        [[0.3015],
         [0.4619]]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">P2</span> <span class="o">=</span> <span class="n">pointset2</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="n">P2</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([[[0.2435, 0.2435, 0.2435, 0.2435],
         [0.1213, 0.1213, 0.1213, 0.1213]],

        [[0.7581, 0.7581, 0.7581, 0.7581],
         [0.8408, 0.8408, 0.8408, 0.8408]],

        [[0.6380, 0.6380, 0.6380, 0.6380],
         [0.9607, 0.9607, 0.9607, 0.9607]],

        [[0.4217, 0.4217, 0.4217, 0.4217],
         [0.5043, 0.5043, 0.5043, 0.5043]],

        [[0.4438, 0.4438, 0.4438, 0.4438],
         [0.2772, 0.2772, 0.2772, 0.2772]],

        [[0.1088, 0.1088, 0.1088, 0.1088],
         [0.3275, 0.3275, 0.3275, 0.3275]],

        [[0.3015, 0.3015, 0.3015, 0.3015],
         [0.4619, 0.4619, 0.4619, 0.4619]]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">P1</span> <span class="o">=</span> <span class="n">pointset1</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">P1</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([[[0.4085, 0.4046, 0.5993, 0.4726],
         [0.5223, 0.2863, 0.2879, 0.7379]],

        [[0.4085, 0.4046, 0.5993, 0.4726],
         [0.5223, 0.2863, 0.2879, 0.7379]],

        [[0.4085, 0.4046, 0.5993, 0.4726],
         [0.5223, 0.2863, 0.2879, 0.7379]],

        [[0.4085, 0.4046, 0.5993, 0.4726],
         [0.5223, 0.2863, 0.2879, 0.7379]],

        [[0.4085, 0.4046, 0.5993, 0.4726],
         [0.5223, 0.2863, 0.2879, 0.7379]],

        [[0.4085, 0.4046, 0.5993, 0.4726],
         [0.5223, 0.2863, 0.2879, 0.7379]],

        [[0.4085, 0.4046, 0.5993, 0.4726],
         [0.5223, 0.2863, 0.2879, 0.7379]]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">P3</span> <span class="o">=</span> <span class="p">(</span><span class="n">P2</span><span class="o">-</span><span class="n">P1</span><span class="p">)</span>
<span class="n">P3</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([[[-0.1650, -0.1611, -0.3558, -0.2291],
         [-0.4010, -0.1650, -0.1666, -0.6166]],

        [[ 0.3497,  0.3535,  0.1588,  0.2856],
         [ 0.3185,  0.5545,  0.5528,  0.1029]],

        [[ 0.2296,  0.2334,  0.0387,  0.1655],
         [ 0.4384,  0.6744,  0.6727,  0.2228]],

        [[ 0.0132,  0.0171, -0.1776, -0.0509],
         [-0.0179,  0.2180,  0.2164, -0.2336]],

        [[ 0.0353,  0.0392, -0.1555, -0.0288],
         [-0.2450, -0.0090, -0.0107, -0.4607]],

        [[-0.2997, -0.2958, -0.4905, -0.3638],
         [-0.1947,  0.0413,  0.0396, -0.4104]],

        [[-0.1069, -0.1030, -0.2977, -0.1710],
         [-0.0604,  0.1756,  0.1739, -0.2760]]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">P3</span> <span class="o">=</span> <span class="n">P3</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">P3</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([[[-0.1650, -0.4010],
         [-0.1611, -0.1650],
         [-0.3558, -0.1666],
         [-0.2291, -0.6166]],

        [[ 0.3497,  0.3185],
         [ 0.3535,  0.5545],
         [ 0.1588,  0.5528],
         [ 0.2856,  0.1029]],

        [[ 0.2296,  0.4384],
         [ 0.2334,  0.6744],
         [ 0.0387,  0.6727],
         [ 0.1655,  0.2228]],

        [[ 0.0132, -0.0179],
         [ 0.0171,  0.2180],
         [-0.1776,  0.2164],
         [-0.0509, -0.2336]],

        [[ 0.0353, -0.2450],
         [ 0.0392, -0.0090],
         [-0.1555, -0.0107],
         [-0.0288, -0.4607]],

        [[-0.2997, -0.1947],
         [-0.2958,  0.0413],
         [-0.4905,  0.0396],
         [-0.3638, -0.4104]],

        [[-0.1069, -0.0604],
         [-0.1030,  0.1756],
         [-0.2977,  0.1739],
         [-0.1710, -0.2760]]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">P3</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>torch.Size([7, 4, 2])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">flows</span> <span class="o">=</span> <span class="n">flow</span><span class="p">(</span><span class="n">pointset1</span><span class="p">)</span>
<span class="n">flows</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([[0.2122, 0.3470],
        [0.2082, 0.1043],
        [0.4569, 0.1055],
        [0.2841, 0.6927]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">affinity_from_flow</span><span class="p">(</span><span class="n">flows</span><span class="p">,</span><span class="n">P3</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="p">(</span><span class="n">P3</span> <span class="o">*</span> <span class="n">flows</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([[-0.1741, -0.0507, -0.1801, -0.4922],
        [ 0.1847,  0.1314,  0.1309,  0.1524],
        [ 0.2008,  0.1189,  0.0887,  0.2013],
        [-0.0034,  0.0263, -0.0583, -0.1763],
        [-0.0775,  0.0072, -0.0722, -0.3273],
        [-0.1312, -0.0573, -0.2199, -0.3876],
        [-0.0436, -0.0031, -0.1177, -0.2398]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">flows</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([[0.4067, 0.2329, 0.4689, 0.7487],
        [0.4067, 0.2329, 0.4689, 0.7487],
        [0.4067, 0.2329, 0.4689, 0.7487],
        [0.4067, 0.2329, 0.4689, 0.7487]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Testing-the-function">Testing the function<a class="anchor-link" href="#Testing-the-function"> </a></h3>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">pointset1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">pointset2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">flow</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">P</span> <span class="o">=</span> <span class="n">affinity_matrix_from_pointset_to_pointset</span><span class="p">(</span><span class="n">pointset1</span><span class="p">,</span><span class="n">pointset2</span><span class="p">,</span><span class="n">flow</span><span class="p">(</span><span class="n">pointset1</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">P</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([[0.3737, 0.3304, 0.3672, 0.3083, 0.6199, 0.4186, 0.5384],
        [0.9048, 0.9899, 0.9298, 1.1175, 0.8538, 0.9476, 1.0344],
        [0.0093, 0.0092, 0.0087, 0.0064, 0.0021, 0.0050, 0.0013],
        [0.0418, 0.0235, 0.0357, 0.0117, 0.0879, 0.0362, 0.0285]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">P</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([2.9564, 6.7778, 0.0421, 0.2653])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">P</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">@</span> <span class="n">P</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([[0.1264, 0.1118, 0.1242, 0.1043, 0.2097, 0.1416, 0.1821],
        [0.1335, 0.1460, 0.1372, 0.1649, 0.1260, 0.1398, 0.1526],
        [0.2215, 0.2183, 0.2059, 0.1527, 0.0507, 0.1188, 0.0321],
        [0.1575, 0.0885, 0.1345, 0.0442, 0.3312, 0.1366, 0.1075]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Putting-the-pieces-together">Putting the pieces together<a class="anchor-link" href="#Putting-the-pieces-together"> </a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="The-Loss-Function:-KL-Divergence">The Loss Function: KL Divergence<a class="anchor-link" href="#The-Loss-Function:-KL-Divergence"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Previously, our network used a frobenius norm between matrices as the loss function. Now, it is comparing probability distributions, rather than distance matrices, and so we want something more robust.</p>
<p>We'll start by using the simplest possible divergence: the KL Divergence</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">loss</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">KLDivLoss</span><span class="p">(</span><span class="n">reduction</span> <span class="o">=</span> <span class="s1">&#39;batchmean&#39;</span><span class="p">,</span><span class="n">log_target</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">Pg</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="n">Pe</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="n">Pg_log</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Pg</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">loss</span><span class="p">(</span><span class="n">Pg_log</span><span class="p">,</span><span class="n">Pe</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor(2.9520)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now to put the pieces together, into a <code>FlowEmbedder</code> Network!</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="DiffusionFlowEmbedder" class="doc_header"><code>class</code> <code>DiffusionFlowEmbedder</code><a href="https://github.com/professorwug/directed_graphs/tree/master/directed_graphs/diffusion_flow_embedding.py#L84" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>DiffusionFlowEmbedder</code>(<strong><code>X</code></strong>, <strong><code>flows</code></strong>, <strong><code>t</code></strong>=<em><code>4</code></em>, <strong><code>sigma_graph</code></strong>=<em><code>0.5</code></em>, <strong><code>sigma_embedding</code></strong>=<em><code>0.5</code></em>, <strong><code>embedding_dimension</code></strong>=<em><code>2</code></em>, <strong><code>device</code></strong>=<em><code>device(type='cpu')</code></em>) :: <code>Module</code></p>
</blockquote>
<p>Base class for all neural network modules.</p>
<p>Your models should also subclass this class.</p>
<p>Modules can also contain other Modules, allowing to nest them in
a tree structure. You can assign the submodules as regular attributes::</p>

<pre><code>import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))

</code></pre>
<p>Submodules assigned in this way will be registered, and will have their
parameters converted too when you call :meth:<code>to</code>, etc.</p>
<p>.. note::
    As per the example above, an <code>__init__()</code> call to the parent class
    must be made before assignment on the child.</p>
<p>:ivar training: Boolean represents whether this module is in training or
                evaluation mode.
:vartype training: bool</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

</div>


